import glob
import struct
import zlib

# Constants
POLYNOMIAL = 0x04C11DB7
INITIAL_VALUE = 0xFFFFFFFF
OUTPUT_XOR = 0x0
REFLECT_INPUT = True
REFLECT_OUTPUT = True

# Function to reflect the bits (Reverse the bit order of an integer)
def reflect_bits(value, bit_length=32):
    reflected = 0
    for i in range(bit_length):
        if value & (1 << i):
            reflected |= (1 << (bit_length - 1 - i))
    return reflected

# Calculate checksum value
def crc32_patch(file_path):
    with open(file_path, 'rb') as f:
        data = f.read()

    # Print the existing CRC32 bytes
    existing_crc = struct.unpack('<I', data[:4])[0]
    print(f"Existing CRC32 from file: {hex(existing_crc)}")

    # crc32 | JAMCRC
    crc = INITIAL_VALUE
    data_to_crc = data[4:]  # Exclude the first 4 bytes
    
    for byte in data_to_crc:
        if REFLECT_INPUT:
            byte = reflect_bits(byte, 8)
        crc ^= byte << 24
        for _ in range(8):
            if crc & 0x80000000:
                crc = (crc << 1) ^ POLYNOMIAL
            else:
                crc <<= 1
        crc &= 0xFFFFFFFF

    # Reflect the output CRC32 if needed
    if REFLECT_OUTPUT:
        crc = reflect_bits(crc, 32)

    crc ^= OUTPUT_XOR

    # Open the savefile again and correct the checksum
    with open(file_path, 'r+b') as f:
        f.seek(0)
        f.write(struct.pack('<I', crc))

    print(f"Patched CRC32 checksum: {hex(crc)}")

# Path to the savefiles
save_file_path = './build/*.sav'

for save_file_path in glob.glob(save_file_path):
    crc32_patch(save_file_path)